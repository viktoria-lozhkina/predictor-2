from flask import Flask, render_template, request, redirect, url_for
# Импортируем нужные функции и классы из библиотеки Flask: Flask (основной класс приложения),
# render_template (для рендеринга HTML-шаблонов), request (для обработки входящих данных), 
# redirect (для перенаправления пользователей) и url_for (для построения URL-адресов).

from flask_sqlalchemy import SQLAlchemy
# Импортируем класс SQLAlchemy для работы с базами данных.

app = Flask(__name__)
# Создаем экземпляр приложения Flask.

app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'
# Настраиваем URI для подключения к базе данных SQLite. База данных будет находиться в файле database.db.
#app.config — это словарь конфигурации вашего приложения Flask, который используется для хранения различных параметров настройки
#SQLALCHEMY_DATABASE_URI — это ключ в словаре конфигурации, который указывает на адрес вашей базы данных.
#Этот ключ специфичен для библиотеки Flask-SQLAlchemy, и он нужен для того, чтобы библиотека знала, как подключаться к базе данных и куда сохранять данные.
#sqlite:///database.db — это сама строка подключения к базе данных.


app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
# Отключаем отслеживание изменений объектов SQLAlchemy, чтобы не было лишних затрат по памяти.
#app.config — это словарь конфигурации вашего Flask-приложения. Он используется для хранения различных параметров настройки, которые влияют на поведение приложения.
#SQLALCHEMY_TRACK_MODIFICATIONS контролирует, отслеживает ли SQLAlchemy изменения объектов в приложении.

db = SQLAlchemy(app)
# Создаем экземпляр SQLAlchemy, передавая ему приложение Flask для настройки.

class DynamicTable(db.Model):
    # Определяем модель DynamicTable, которая будет представлять таблицу в базе данных
    id = db.Column(db.Integer, primary_key=True)
    # Создаем колонку 'id' типа Integer, которая будет являться первичным ключом
    data = db.Column(db.String(200), nullable=False)
    # Создаем колонку 'data' типа String с максимальной длиной 200 символов, которая не может быть пустой (nullable=False)
    data_type = db.Column(db.String(100), nullable=False)
    # Создаем колонку 'data_type' типа String с максимальной длиной 100 символов, которая также не может быть пустой (nullable=False)


@app.cli.command("db_init")
# Определяем новую команду CLI (Command Line Interface) для инициализации базы данных с именем "db_init"
# Команды, определенные с помощью этого декоратора app.cli, могут быть вызваны из командной строки, когда вы запускаете приложение с помощью утилиты Flask.
#В данном случае строка "db_init" задает имя команды, которую вы будете использовать в командной строке. Это имя будет указано, когда вы хотите вызвать команду.
def db_init():
    """Инициализация базы данных."""
    db.create_all()  # Создание обновленной структуры базы данных. Создаем все таблицы в базе данных, которые описаны в моделях (если они еще не существуют)

@app.route('/') 
def index():
    # Определяем маршрут для корневого URL ('/') и связанную с ним функцию index.
    tables = DynamicTable.query.all()
    # Получаем все записи из таблицы DynamicTable.

    #Декоратор @app.route('/') связывает URL-адрес (в данном случае корневой адрес сайта, который обозначается как /) с функцией index.
    #Каждый раз, когда пользователь переходит на этот URL, будет вызываться функция index.
    #Функция index выполняется, когда пользователь посещает корневой адрес вашего веб-приложения.
    #Обычно она отвечает за то, чтобы возвращать HTML-страницу (или другой контент) для этого URL.
    #.query.all(): Используя метод .query.all(), мы запрашиваем все записи из таблицы, представленной моделью DynamicTable.
    #В результате переменная tables будет содержать список всех объектов, соответствующих записям в этой таблице.
    
    return render_template('index.html', tables=tables)
    # Рендерим шаблон index.html, передавая ему данные 'tables'.


@app.route('/create_table', methods=['POST'])
# Определяем маршрут '/create_table', который обрабатывает только POST-запросы.
def create_table():
    table_name = request.form.get('table_name')
    # Извлекаем имя таблицы из данных формы, отправленных в POST-запросе.
    #В Flask объект request представляет собой текущий HTTP-запрос. Он содержит всю информацию о запросе, пришедшем от клиента (например, браузера), включая параметры, данные формы, заголовки и файлы
    #request.form — это атрибут объекта request, который представляет собой словарь, содержащий данные, отправленные через HTML-форму в вашем веб-приложении.
    #Метод .get('table_name') используется для извлечения значения по ключу из словаря request.form. В данном случае ключ — это строка 'table_name'.

    return redirect(url_for('index'))


@app.route('/add_data', methods=['POST'])
# Определяем маршрут '/add_data', который также обрабатывает только POST-запросы.
def add_data():
    data = request.form.get('data')
    # Извлекаем основное значение из данных формы (поле с именем 'data').
    data_type = request.form.get('data_type')
     # Извлекаем дополнительный тип данных из данных формы (поле с именем 'data_type').
    
    new_entry = DynamicTable(data=data, data_type=data_type)
    # Создаем новый объект записи в модели DynamicTable с извлеченными значениями (data и data_type).
    
    db.session.add(new_entry)
    # Добавляем новую запись в текущую сессию базы данных.
    # Сохраняем изменения сессии в базе данных.

    return redirect(url_for('index'))
    # Перенаправляем пользователя обратно на главную страницу после добавления данных.

@app.route('/delete_data/<int:id>', methods=['POST'])
def delete_data(id):
    # Определяем маршрут для удаления данных, принимающий ID записи и ожидающий POST-запросы.
    entry = DynamicTable.query.get(id)
    # Находим запись в таблице по переданному ID.
    #query — это атрибут, предоставляемый SQLAlchemy, который позволяет выполнять запросы к базе данных для данной модели. 
    #Метод get(id) используется для получения конкретной записи из таблицы по первичному ключу
    
    db.session.delete(entry)
    # Удаляем найденную запись из сессии SQLAlchemy.
    
    db.session.commit()
    # Сохраняем изменения в базе данных.
    
    return redirect(url_for('index'))
    # Перенаправляем пользователя на главную страницу после удаления данных.

@app.route('/update_data/<int:id>', methods=['POST'])
def update_data(id):
    # Определяем маршрут для обновления данных, принимающий ID записи и ожидающий POST-запросы.
    entry = DynamicTable.query.get(id)
    # Находим запись в таблице по переданному ID.
    
    entry.data = request.form.get('data')
    # Обновляем поле 'data' новой информацией из формы.
    
    db.session.commit()
    # Сохраняем изменения в базе данных.
    
    return redirect(url_for('index'))
    # Перенаправляем пользователя на главную страницу после обновления данных.

if __name__ == '__main__':
    with app.app_context():
        db.create_all()  # Создание базы данных и таблиц, если они не существуют.
#if __name__ == '__main__':: Этот блок кода проверяет, является ли текущий модуль (файл) исполняемым программным модулем.
    #Когда вы запускаете Python-скрипт, интерпретатор устанавливает специальную переменную __name__ в значение __main__. Это означает, что файл запускается напрямую, например, с помощью команды python script.py.    
# app.app_context() создает контекст приложения, который нужен для выполнения функций, связанных с текущим приложением (например, доступ к объекту базы данных, настройкам приложения и т.д.).
#create_all() — это метод, который создает все таблицы в базе данных, определенные в ваших моделях SQLAlchemy, если они еще не существуют.
    
    app.run(debug=True)
    # Запускаем приложение в режиме отладки, чтобы видеть ошибки и изменения в реальном времени.
